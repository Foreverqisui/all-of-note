# 谷粒学院笔记

# 第一天 环境搭建

# 一、数据库表设计

# 二、创建项目结构

## 创建父工程 --pom类型 管理依赖版本和放公共依赖

### pom配置

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <modules>
        <module>guli-service</module>
    </modules>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.1</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.pc</groupId>
    <artifactId>guli_parent</artifactId>
    <packaging>pom</packaging>
    <version>0.0.1-SNAPSHOT</version>
    <name>guli_parent</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>1.8</java.version>
        <guli.version>0.0.1-SNAPSHOT</guli.version>
        <mybatis-plus.version>3.0.5</mybatis-plus.version>
        <velocity.version>2.0</velocity.version>
        <swagger.version>2.7.0</swagger.version>
        <aliyun.oss.version>2.8.3</aliyun.oss.version>
        <jodatime.version>2.10.1</jodatime.version>
        <poi.version>3.17</poi.version>
        <commons-fileupload.version>1.3.1</commons-fileupload.version>
        <commons-io.version>2.6</commons-io.version>
        <httpclient.version>4.5.1</httpclient.version>
        <jwt.version>0.7.0</jwt.version>
        <aliyun-java-sdk-core.version>4.3.3</aliyun-java-sdk-core.version>
        <aliyun-sdk-oss.version>3.1.0</aliyun-sdk-oss.version>
        <aliyun-java-sdk-vod.version>2.15.2</aliyun-java-sdk-vod.version>
        <aliyun-java-vod-upload.version>1.4.11</aliyun-java-vod-upload.version>
        <aliyun-sdk-vod-upload.version>1.4.11</aliyun-sdk-vod-upload.version>
        <fastjson.version>1.2.28</fastjson.version>
        <gson.version>2.8.2</gson.version>
        <json.version>20170516</json.version>
        <commons-dbutils.version>1.7</commons-dbutils.version>
        <canal.client.version>1.1.0</canal.client.version>
        <docker.image.prefix>zx</docker.image.prefix>
        <cloud-alibaba.version>0.2.2.RELEASE</cloud-alibaba.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <!--Spring Cloud-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--mybatis-plus 持久层-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>

            <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->
            <dependency>
                <groupId>org.apache.velocity</groupId>
                <artifactId>velocity-engine-core</artifactId>
                <version>${velocity.version}</version>
            </dependency>

            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger ui-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>${swagger.version}</version>
            </dependency>

            <!--aliyunOSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun.oss.version}</version>
            </dependency>

            <!--日期时间工具-->
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>${jodatime.version}</version>
            </dependency>

            <!--xls-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>${poi.version}</version>
            </dependency>
            <!--xlsx-->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>${poi.version}</version>
            </dependency>

            <!--文件上传-->
            <dependency>
                <groupId>commons-fileupload</groupId>
                <artifactId>commons-fileupload</artifactId>
                <version>${commons-fileupload.version}</version>
            </dependency>

            <!--commons-io-->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${commons-io.version}</version>
            </dependency>

            <!--httpclient-->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>${httpclient.version}</version>
            </dependency>

            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>${gson.version}</version>
            </dependency>

            <!-- JWT -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jwt.version}</version>
            </dependency>

            <!--aliyun-->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>${aliyun-java-sdk-core.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun-sdk-oss.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-vod</artifactId>
                <version>${aliyun-java-sdk-vod.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-vod-upload</artifactId>
                <version>${aliyun-java-vod-upload.version}</version>
            </dependency>
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-sdk-vod-upload</artifactId>
                <version>${aliyun-sdk-vod-upload.version}</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>${json.version}</version>
            </dependency>

            <dependency>
                <groupId>commons-dbutils</groupId>
                <artifactId>commons-dbutils</artifactId>
                <version>${commons-dbutils.version}</version>
            </dependency>

            <dependency>
                <groupId>com.alibaba.otter</groupId>
                <artifactId>canal.client</artifactId>
                <version>${canal.client.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

### 创建子模块--service

#### pom配置

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>guli_parent</artifactId>
        <groupId>com.pc</groupId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>guli-service</artifactId>
    <packaging>pom</packaging>
    <modules>
        <module>service_edu</module>
    </modules>

    <dependencies>

        <dependency>
            <groupId>com.pc</groupId>
            <artifactId>guli-service</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>

        <!--<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </dependency>-->

        <!--hystrix依赖，主要是用  @HystrixCommand -->
        <!--<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>-->

        <!--服务注册-->
        <!-- <dependency>
             <groupId>org.springframework.cloud</groupId>
             <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
         </dependency>-->
        <!--服务调用-->
        <!-- <dependency>
             <groupId>org.springframework.cloud</groupId>
             <artifactId>spring-cloud-starter-openfeign</artifactId>
         </dependency>-->

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!--mybatis-plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>

        <!--mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 -->
        <dependency>
            <groupId>org.apache.velocity</groupId>
            <artifactId>velocity-engine-core</artifactId>
        </dependency>

        <!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>

        <!--lombok用来简化实体类：需要安装lombok插件-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>

        <!--xls-->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
        </dependency>

        <dependency>
            <groupId>commons-fileupload</groupId>
            <artifactId>commons-fileupload</artifactId>
        </dependency>

        <!--httpclient-->
        <dependency>
            <groupId>org.apache.httpcomponents</groupId>
            <artifactId>httpclient</artifactId>
        </dependency>
        <!--commons-io-->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
        </dependency>
        <!--gson-->
        <dependency>
            <groupId>com.google.code.gson</groupId>
            <artifactId>gson</artifactId>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
        </dependency>
    </dependencies>

</project>
```

### 创建孙模块--service_edu

#### 代码生成器

```java
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.DateType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import org.junit.Test;

/**
 * @author
 * @since 2018/12/13
 */
public class CodeGenerator {

    @Test
    public void run() {

        // 1、创建代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 2、全局配置
        GlobalConfig gc = new GlobalConfig();

        gc.setOutputDir("D:\\尚硅谷项目\\谷粒学院\\guli-parent\\guli-service\\service_edu" + "/src/main/java");

        gc.setAuthor("testjava");
        gc.setOpen(false); //生成后是否打开资源管理器
        gc.setFileOverride(false); //重新生成时文件是否覆盖

        gc.setServiceName("%sService");    //去掉Service接口的首字母I

        gc.setIdType(IdType.ID_WORKER); //主键策略
        gc.setDateType(DateType.ONLY_DATE);//定义生成的实体类中日期类型
        gc.setSwagger2(true);//开启Swagger2模式

        mpg.setGlobalConfig(gc);

        // 3、数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://localhost:3306/guli-school?serverTimezone=GMT");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("pc");
        dsc.setPassword("123456");
        dsc.setDbType(DbType.MYSQL);
        mpg.setDataSource(dsc);

        // 4、包配置
        PackageConfig pc = new PackageConfig();

        pc.setModuleName("eduService"); //模块名
        pc.setParent("com.pc");
        pc.setController("controller");
        pc.setEntity("entity");
        pc.setService("service");
        pc.setMapper("mapper");
        mpg.setPackageInfo(pc);

        // 5、策略配置
        StrategyConfig strategy = new StrategyConfig();

        strategy.setInclude("edu_teacher");
        strategy.setNaming(NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略
        strategy.setTablePrefix(pc.getModuleName() + "_"); //生成实体时去掉表前缀

        strategy.setColumnNaming(NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
        strategy.setEntityLombokModel(true); // lombok 模型 @Accessors(chain = true) setter链式操作

        strategy.setRestControllerStyle(true); //restful api风格控制器
        strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符

        mpg.setStrategy(strategy);

        // 6、执行
        mpg.execute();
    }
}
g.setStrategy(strategy);
```

#### 实现controller类

```java
@RestController
@RequestMapping("/eduService/edu-teacher")
public class EduTeacherController {

    /**
     * 注入讲师service属性
     * */
    @Autowired
    private EduTeacherService teacherService;

    /**
     * 查询讲师表所有数据
     * */
    @GetMapping("findAl")
    public List<EduTeacher> findAllTeacher(){
        //调用service方法实现查询所有的操作
        List<EduTeacher> list = teacherService.list(null);
        return list;
    }

}
```

#### 实现application主运行类

```java
@SpringBootApplication
public class EduApplication {
    public static void main(String[] args) {
        SpringApplication.run(EduApplication.class,args);
    }
}
```

#### 创建配置类 配置mapper扫描和其他

```java
@Configuration
@MapperScan("com.pc.eduService.mappere")
public class EduConfig {

}
```

#### 整合swagger进行接口测试--创建公共模块，方便所有模块使用

> 问题：Whitelabel Error [Page]
> 
> 需要启动类要加包扫描
> 
> ```java
> @SpringBootApplication(scanBasePackages="com.exam.controller")
> ```

* 生成在线文档

* 方便接口测试

* 访问网址--[Swagger UI](http://localhost/swagger-ui.html)

```java
/**
 * @author foreverqisui
 * swggerConfig 配置类
 */
//配置类
@Configuration
//swagger注解
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket webApiConfig() {
        return new Docket(DocumentationType.SWAGGER_2)
                .groupName("webApi")
                .apiInfo(webApiInfo())
                .select()
                .paths(Predicates.not(PathSelectors.regex("/admin/.*")))
                .paths(Predicates.not(PathSelectors.regex("/error.*")))
                .build();

    }

    private ApiInfo webApiInfo() {

        return new ApiInfoBuilder()
                .title("网站-课程中心API文档")
                .description("本文档描述了课程中心微服务接口定义")
                .version("1.0")
                .contact(new Contact("java", "http://foreverqisui.top", "2592303898@qq.com"))
                .build();
    }
}      
```

### 统一结果返回

##### json数据格式

* 对象数组

```java
    {
        "success": 布尔-- 响应是否成功
        "code": 数字-- 响应码
        "message": 字符串-- 返回消息
        "data" : HashMap-- 返回数据，，放在键值对当中
    }
```

##### 步骤

* 在common中创建子模块common_utils

* 创建一个interface 定义数据返回状态码
  
  * 成功：5201314
  
  * 失败：1825555

```java
public interface ResultCode {

    /**
     * SUCCESS 成功数据访回状态码
     * */
    Integer SUCCESS = 5201314;

    /**
     * ERROR 失败数据访回状态码
     * */
    Integer ERROR = 1825555;
}
```

* 定义返回数据格式

```java
@Data
public class ResultBack {


    /**
     * 通过格式定义，返回是否成功的状态码
     * */
    @ApiModelProperty(value = "是否成功")
    private Boolean success;

    /**
     * 通过格式定义，设定返回码
     * */
    @ApiModelProperty(value = "返回码")
    private int code;

    /**
     * 通过格式定义，返回消息值
     * */
    @ApiModelProperty(value = "返回消息")
    private String message;

    /**
     * 通过格式定义，返回数据
     * */
    @ApiModelProperty(value = "返回数据")
    private Map<String, Object> data = new HashMap<String, Object>();

    /**
     * 使构造方法私有
     * */
    private ResultBack(){}

    /**
     * 设置成功的静态方法
     * */
    public static ResultBack ok(){
        ResultBack resultBack = new ResultBack();
        resultBack.setSuccess(true);
        resultBack.setCode(ResultCode.SUCCESS);
        resultBack.setMessage("恭喜你，成功了");
        return resultBack;
    }
    /**
     * 设置失败的静态方法
     * */
    public static ResultBack error(){
        ResultBack resultBack = new ResultBack();
        resultBack.setSuccess(false);
        resultBack.setCode(ResultCode.ERROR);
        resultBack.setMessage("不要灰心，仔细检查，总会对的");
        return resultBack;
    }

    public ResultBack success(Boolean success){
        this.setSuccess(success);
        return this;
    }
    public ResultBack message(String message){
        this.setMessage(message);
        return this;
    }
    public ResultBack code(Integer code){
        this.setCode(code);
        return this;
    }
    public ResultBack data(Map<String,Object> map){
        this.setData(map);
        return this;
    }

}
```

* 使用统一结果
  
  * 在guli-service中引入common_utils
    
    ```java
    <dependency>
                <groupId>com.pc</groupId>
                <artifactId>common_utils</artifactId>
                <version>0.0.1-SNAPSHOT</version>
            </dependency>
    ```
  
  * 把接口方法 的返回结果都设置成ResultBack

```java
   /**
     * 查询讲师表所有数据
     * */
    @GetMapping("/findAll")
    public ResultBack findAllTeacher(){
        //调用service方法实现查询所有的操作
        List<EduTeacher> list = teacherService.list(null);
        return ResultBack.ok().data("item",list);
    }

    /**
     * 逻辑删除讲师
     * */
    @DeleteMapping("{id}")
    public ResultBack deleteTeacher(@PathVariable String id){
        boolean b = teacherService.removeById(id);
        if (b){
            return ResultBack.ok();
        }else {
            return ResultBack.error();
        }
    }
```

### 设置分页功能

* 配置类里写入配置插件

```java
/**
     * 分页插件
     * */
    @Bean
    public PaginationInterceptor paginationInterceptor(){
        return new PaginationInterceptor();
    }
```

* controller类里设置分页查询的方法

```java
 /**
     * 分页查询讲师的方法
     * @param current 当前页
     * @param limit 每页记录数
     * */
    @GetMapping("pageTeacher/{current}/{limit}")
    public ResultBack pageListTeacher(@PathVariable long current, @PathVariable long limit){

        //创建page对象
        Page<EduTeacher> pageTeacher = new Page<>(current, limit);
        //调用方法实现分页
        teacherService.page(pageTeacher,null);
        //总记录数
        long total = pageTeacher.getTotal();
        //数据list集合
        List<EduTeacher> records = pageTeacher.getRecords();

        return ResultBack.ok().data("total",total).data("records",records);
    }
```

* 条件查询分页功能

```java
   /**
     * 条件查询带分页的方法
     * */
    @PostMapping("pageTeacherCondition/{current}/{limit}")
    public ResultBack pageTeacherCondition(@PathVariable long current,
                                           @PathVariable long limit, 
                                           @RequestBody(required = false) TeacherQuery teacherQuery){

        //创建page对象
        Page<EduTeacher> pageTeacher = new Page<>(current, limit);
        //构建条件
        QueryWrapper<EduTeacher> wrapper = new QueryWrapper<>();
        //多条件组合查询
        String name = teacherQuery.getName(),begin = teacherQuery.getBegin(),end = teacherQuery.getEnd();
        Integer level = teacherQuery.getLevel();
        if (name != null){
            //模糊查询
            wrapper.like("name",name);
        }
        if (level != null){
            //精准查询
            wrapper.eq("level",level);
        }
        if (begin != null){
            //范围查询 ge代表大于等于
            wrapper.ge("gmt_create",begin);
        }
        if (end != null){
            //范围查询 le代表小于等于
            wrapper.le("gmt_create",end);
        }


        teacherService.page(pageTeacher, wrapper);
        //总记录数
        long total = pageTeacher.getTotal();
        //数据list集合
        List<EduTeacher> records = pageTeacher.getRecords();

        return ResultBack.ok().data("total",total).data("records",records);

    }total).data("records",records);

    }
```

### 添加讲师的方法

* 自动填充时间功能--@TableFiel

```java
   @ApiModelProperty(value = "创建时间")
    @TableField(fill= FieldFill.INSERT)
    private Date gmtCreate;

    @ApiModelProperty(value = "更新时间")
    @TableField(fill=FieldFill.INSERT_UPDATE)
    private Date gmtModified;ified;
```

* 自动填充时间值设置

```java
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        //传递参数是属性名，而不是字段名
        this.setFieldValByName("gmtCreate", new Date(), metaObject);
        this.setFieldValByName("gmtModified", new Date(), metaObject);
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("gmtModified", new Date(), metaObject);
    }
```

* 核心逻辑编写

```java
  /**
     * 添加讲师的方法
     * */
    @PostMapping("addTeacher")
    public ResultBack addTeacher(@RequestBody EduTeacher eduTeacher){
        boolean save = teacherService.save(eduTeacher);
        if (save){
            return ResultBack.ok();
        }
        return ResultBack.error();
    }
```

### 讲师修改功能

#### 数据回显

```java
   /**
     * 根据讲师id进行查询
     * */
    @GetMapping("getTeacher/{id}")
    public ResultBack getTeacher(@PathVariable String id){
        EduTeacher byId = teacherService.getById(id);
        return ResultBack.ok().data("teacher",byId);
    }
```

#### 数据修改

```java
   /**
     * 讲师修改功能
     * */
    @PostMapping("updateTeacher")
    public ResultBack updateTeacher(@RequestBody EduTeacher eduTeacher){
        boolean b = teacherService.updateById(eduTeacher);
        if (b){
            return ResultBack.ok();
        }
        return ResultBack.error();
    }
```

## 统一异常处理

### 全局异常处理

```java
/**
 * @author foreverqisui
 * 全局异常
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    @ResponseBody
    public ResultBack error(Exception e){
        e.printStackTrace();
        return ResultBack.error().message("习以为常，看不出来，没有问题，关机重启");
    }
}
```

### 特定异常处理

### 自定义异常处理

* 创建自定义异常类

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MyException extends RuntimeException {
    /**
     * 状态码
     * */
    private Integer code;
    /**
     * 异常信息
     * */
    private String msg;
}
```

```java
  /**
     * 自定义异常
     * */

    @ExceptionHandler(MyException.class)
    @ResponseBody
    public ResultBack error(MyException e){
        e.printStackTrace();
        return ResultBack.error().code(e.getCode()).message(e.getMsg());
    }
```

## 统一日志处理

### Logback

* 日志级别：ERROR、 WARN、 INFO、 DEBUG、 ALL

## guli前端部分

端口号改成80 后端加注解@CrossOrigin 防止跨域请求异常

```java
这是dev.env.js 文件
module.exports = merge(prodEnv, {
  NODE_ENV: '"development"',
  BASE_API: '"http://localhost:80"',
})
```

再改一下src下login里面的文件 登录同获取信息的方式

```java
export function getInfo(token) {
  return request({
    url: '/eduservice/user/info',
    method: 'get',
    params: { token }
  })
}
```

### 开发步骤

* #### 添加路由（菜单）
  
  * 在router下面的index里面 根据模板添加

```java
 {
     //这是父亲模板
    path: '/example',
    //布局 
    component: Layout,
     //重定向到
    redirect: '/example/table',
    name: 'Example',
     //路由名称 和 路由图标在svg下面
    meta: { title: 'Example', icon: 'example' },
    //这是孩子模板
     children: [
      {
        path: 'table',
        name: 'Table',
        component: () => import('@/views/table/index'),
        meta: { title: 'Table', icon: 'table' }
      },
      {
        path: 'tree',
        name: 'Tree',
        //路由对应的页面 页面在view下面
        component: () => import('@/views/tree/index'),
        meta: { title: 'Tree', icon: 'tree' }
      }
    ]
  },
```

* 在api下面添加对应的js文件

```java
//导入axios配置 进行异步请求
import request from '@/utils/request'
//模板 定义接口地址和参数
export function getList(params) {
  return request({
    url: '/table/list',
    method: 'get',
    params
  })
}
```

* 在创建的vue界面下引入js文件，调用方法实现功能

* #### 创建路由对应的页面 -- 模板页面
  
  ```html
  <template>
   <div class="app-container">
      模板 这里写的是组件 用来在页面上展示数据
    </div>
  </template>
  <script>
  // 引入调用teache.js文件
  
  export default{
    // 写核心代码
    data() {
      // 定义变量和初始值
      return {
  
      }
    },
    created() {
      // 页面渲染之前执行，一般调用methods定义的方法
      // 调用
      this.getList()
    },
    methods: {
      // 创建具体的方法，调用teacher.js定义的方法
      getList() {
  
      }
    }
  }
  </script>
  ```
  
  * ```java
    
    ```
    
     {
    
            path: 'save',
            name: '添加讲师',
            component: () => import('@/views/edu/teacher/save'),
            meta: { title: '添加讲师', icon: 'tree' }
          }
    
    ```
    
    ```
  
  * 在api下创建对应的js文件
    
    ```java
    import request from '@/utils/request'
    export default {
      // 讲师列表（条件查询）
      // current 当前页， limit 每页记录数 teacherQuery 条件对象
      getTeacherListPage(current, limit, teacherQuery) {
        return request({
          url: '/eduservice/teacher/pageTeacherCondition/' + current + '/' + limit,
          method: 'post',
          // data表示把对象转换成json进行传递到接口里面
          data: teacherQuery
        })
      }
    }
    ```
  
  * 在讲师列表页面 list.vue页面调用定义的接口方法，得到接口返回数据
    
    ```java
    <template>
      <div class="app-container">
        jiangshi
      </div>
    </template>
    <script>
    // 引入调用teache.js文件
    import teacher from '@/api/edu/teacher'
    
    export default{
      // 写核心代码
      data() {
        // 定义变量和初始值
        return {
          list: null,
          page: 1,
          limit: 10,
          total: 0,
          teacherQuery: {}
        }
      },
      created() {
        // 页面渲染之前执行，一般调用methods定义的方法
        // 调用
        this.getList()
      },
      methods: {
        // 创建具体的方法，调用teacher.js定义的方法
        getList() {
          teacher.getTeacherListPage(this.page, this.limit, this.teacherQuery)
            .then(response => {
            // 请求成功 response接口返回的数据
              this.list = response.data.records
              console.log(this.list)
            })
            .catch(error => {
              // 输出请求失败的信息
              console.log(error)
            })
        }
      }
    }
    </script>
    ```
  
  * 把请求接口获取数据在页面进行显示 -- 使用element-ui实现

## <u>** 第六天 借助阿里云oss进行文件上传存储**</u>

## 环境搭建

### 第一步 创建 子模块 service-oss

### 第二步 导入相关依赖

```java
    <!--阿里云oss依赖-->
        <dependency>
            <groupId>com.aliyun.oss</groupId>
            <artifactId>aliyun-sdk-oss</artifactId>
        </dependency>
        <!--日期工具栏依赖-->
        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
        </dependency>
```

### 第三步 编写配置文件

```java
server.port=8002

spring.application.name=service-oss

spring.profiles.active=dev

aliyun.oss.file.endpoint=oss-cn-beijing.aliyuncs.com
aliyun.oss.file.keyid=LTAI5tGJ7e2UYmy2kNpqE8XL
aliyun.oss.file.keysecret=Q3ZdtaKHrO3j8E4a5cLbicZbrrpQ0H
aliyun.oss.file.bucketname=pc5201314
```

### 第四步 解决一个启动报错问题

* 原因：他要访问数据库，但是我没有配置数据的配置文件

* 解决方案
  
  * 1.在配置文件中加上数据库的资源
  
  ```java
  #激活配置文件 需要指定其他的配置文件名称
  spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
  spring.datasource.url=jdbc:mysql://localhost:3306/guli-school?serverTimezone=GMT
  spring.datasource.username=pc
  spring.datasource.password=123456
  ```
  
  * 2.在启动类添加属性

```java
@SpringBootApplication(exclude= DataSourceAutoConfiguration.class)
```

### 第五步 创建一个配置类 读取配置文件的内容

```java
@Component
public class ConstantPropertiesUtils implements InitializingBean {

    @Value("${aliyun.oss.file.endpoint}")
    private String endpoint;
    @Value("${aliyun.oss.file.keyid}")
    private String keyId;
    @Value("${aliyun.oss.file.keysecret}")
    private String keysecret;
    @Value("${aliyun.oss.file.bucketname}")
    private String bucketName;

    /*定义公开静态常量*/
    public static String END_POIND;
    public static String ACCESS_KEY_ID;
    public static String ACCESS_KEY_SECRET;
    public static String BUCKET_NAME;
    @Override
    public void afterPropertiesSet() throws Exception {
        END_POIND = endpoint;
        ACCESS_KEY_ID = keyId;
        ACCESS_KEY_SECRET = keysecret;
        BUCKET_NAME = bucketName;
    }
}
```

### 第六步 创建 cotroller

```java
@RestController
@RequestMapping("/eduoss/fileoss")
public class OssController {
    @Autowired
    private OssService ossService;

    /**
     * 上传头像 的 方法
     * @param file MultipartFile 是用来获取上传文件的
     * */
    @PostMapping
    public ResultBack upLoadOssFile(MultipartFile file){
        //获取oss 的 路径 用来放入数据库中
        String url = ossService.uploadFileAvatar(file);
        return ResultBack.ok().data("url",url);
    }
}
```

### 第七步 创建service

```java
public interface OssService {

    /**
     * 上传头像到oss的方法
     * @param file MultipartFile 是用来获取上传文件的
     * @return 返回的是获取头像的url路径
     * */
    String uploadFileAvatar(MultipartFile file);
}
```

```java
@Service
public class OssServiceImpl implements OssService {
    /**
     * 上传头像到oss的方法
     *
     * @param file MultipartFile 是用来获取上传文件的
     * @return 返回的是获取头像的url路径
     */
    @Override
    public String uploadFileAvatar(MultipartFile file) {

        // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
        String endpoint = ConstantPropertiesUtils.END_POIND;
        // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。
        String accessKeyId = ConstantPropertiesUtils.ACCESS_KEY_ID;
        String accessKeySecret = ConstantPropertiesUtils.ACCESS_KEY_SECRET;
        // 填写Bucket名称，例如examplebucket。
        String bucketName = ConstantPropertiesUtils.BUCKET_NAME;
        //获取文件名称
        String fileName = file.getOriginalFilename();

        //在文件名称里面添加唯一随机的值
        String uuid = UUID.randomUUID().toString();
        //对文件名称进行拼接操作
        fileName+=uuid;
        //把文件按照日期进行分类
        //获取当前日期
        String datePath = new DateTime().toString("yyyy/MM/dd");
        //进行拼接
        fileName = datePath+"/"+fileName;

        // 创建OSSClient实例。
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        try {
            InputStream inputStream = file.getInputStream();
            // 创建PutObject请求。
            ossClient.putObject(bucketName, fileName, inputStream);

            ossClient.shutdown();
            //返回照片路径 通过路径拼接
            return "https://"+bucketName+"."+endpoint+"/"+fileName;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "你是个傻逼";
    }
}
  }
        return "你是个傻逼";
    }
}
```

### 第八步 nginx --反向代理服务器

#### 作用

* 请求转发

* 负载均衡

* 动静分离

#### 需要在nginx.conf中进行转发配置

```java
    server {
        listen       9001;
        server_name  localhost;

         location ~ /eduservice/ {
           proxy_pass   http://localhost:8001;
        }
        location ~ /eduoss/ {
           proxy_pass   http://localhost:8002;
        }
        location ~ /eduvod/ {
           proxy_pass   http://localhost:8003;
        }
}
```

### 第九步前端整合

### 第十步 easyexecl整合使用

* 第一步 引入依赖

```java
<dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>easyexcel</artifactId>
            <version>3.0.2</version>
        </dependency>
```

* 第二步 创建实体类 和execl表对应

```java
@Data
public class DemoData {

    @ExcelProperty("学生编号")
    private Integer sno;

    @ExcelProperty("学生姓名")
    private String snmae;
}
```

* 第三步 写操作测试

```java
public class TestEasyExcel {
    @Test
    public void test() {
        //设置写入文件夹的地址和excel的文件名称
        String fileName ="D:\\test.xlsx";

        //调用easyexcel的方法 实现写操作
        EasyExcel.write(fileName,DemoData.class).sheet("学生列表").doWrite(getDemoData());
    }

    public static List<DemoData> getDemoData() {
        List<DemoData> demoDataList = new ArrayList<>();
        DemoData data = new DemoData();
        for (int i = 0; i < 10; i++) {
            data.setSno(i);
            data.setSnmae("pczs" + i);
            demoDataList.add(data);
        }
        return demoDataList;
    }
```

* 创建监听器

```java
public class ExcelListenter extends AnalysisEventListener<DemoData> {

    /**
     * 一行一行的进行内容读取
     * */
    @Override
    public void invoke(DemoData demoData, AnalysisContext analysisContext) {
        System.out.println(demoData+"pczs");
    }

    //读取表头内容
    @Override
    public void invokeHeadMap(Map<Integer, String> headMap, AnalysisContext context) {
        System.out.println("表头"+headMap);
    }

    /**
     * 读取完成之后的操作
     * */
    @Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {

    }
}
```

* 读操作

```java
        //调用easyexcel的方法 实现读操作
        EasyExcel.read(fileName,DemoData.class,new ExcelListenter()).sheet().doRead();
```

### 第十步 创建课程分类功能

* 首先通过代码生成器生成对应的类

* 完善控制类

* 创建实体类
  
  ```java
  /**
   * @author foreverqisui
   * 文件属性和excel对应 一级分类 二级分类
   */
  @Data
  public class SubjectData {
  
      @ExcelProperty(index=0)
      private String oneSubjectName;
  
      @ExcelProperty(index=1)
      private String twoSubjectName;
  }
  ```

* 创建serviceImpl类
  
  ```java
  @Service
  public class EduSubjectServiceImpl extends ServiceImpl<EduSubjectMapper, EduSubject> implements EduSubjectService {
  
      /**
       * 添加课程分类
       *
       * @param file 上传过来的excel文件
       */
      @Override
      public void saveSubject(MultipartFile file) {
          //文件输入流
          try {
              InputStream in = file.getInputStream();
              EasyExcel.read(in, SubjectData.class,new SubjectExcelListener()).sheet().doRead();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  }
  ```

### 第十一步 创建前端

* 创建对应的路由

```java
  {
    path: '/subject',
    component: Layout,
    redirect: '/subject/list',
    name: '课程分类管理',
    meta: { title: '课程分类管理', icon: 'example' },

    children: [
      {
        path: 'list',
        name: '课程分类列表',
        component: () => import('@/views/edu/teacher/list'),
        meta: { title: '课程分类列表', icon: 'table' }
      },
      {
        path: 'save',
        name: '添加课程分类',
        component: () => import('@/views/edu/teacher/save'),
        meta: { title: '添加课程分类', icon: 'tree' }
      }
    ]
  },
```

### 第十二步创建列表查询的接口

* ##### 创建实体类 -- 一级分类和二级分类
  
  ```java
  /**
   * @author foreverqisui
   * 一级分类
   */
  @Data
  public class OneSubject {
      private String id;
      private String title;
      //一个一级分类有多个二级分类
      private List<TwoSubject> children = new ArrayList<TwoSubject>();
  }
  ;
  }
  ```

* ##### 编写代码 -- 进行封装
  
  ```java
  @Service
  public class EduSubjectServiceImpl extends ServiceImpl<EduSubjectMapper, EduSubject> implements EduSubjectService {
  
      /**
       * 添加课程分类
       *
       * @param file 上传过来的excel文件
       */
      @Override
      public void saveSubject(MultipartFile file, EduSubjectService subjectService) {
          //文件输入流
          try {
              InputStream in = file.getInputStream();
              EasyExcel.read(in, SubjectDa
  ta.class, new SubjectExcelListener(subjectService)).sheet().doRead();
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  
      /**
       * 课程列表展示
       */
      @Override
      public List<OneSubject> getAllOneTwoSubject() {
          //1 查询所有一级分类  parentid = 0
          QueryWrapper<EduSubject> wrapperOne = new QueryWrapper<>();
          wrapperOne.eq("parent_id","0");
          List<EduSubject> oneSubjectList = baseMapper.selectList(wrapperOne);
  
          //2 查询所有二级分类  parentid != 0
          QueryWrapper<EduSubject> wrapperTwo = new QueryWrapper<>();
          wrapperTwo.ne("parent_id","0");
          List<EduSubject> twoSubjectList = baseMapper.selectList(wrapperTwo);
  
          //创建list集合，用于存储最终封装数据
          List<OneSubject> finalSubjectList = new ArrayList<>();
  
          //3 封装一级分类
          //查询出来所有的一级分类list集合遍历，得到每个一级分类对象，获取每个一级分类对象值，
          //封装到要求的list集合里面 List<OneSubject> finalSubjectList
          for (int i = 0; i < oneSubjectList.size(); i++) {
              //得到oneSubjectList每个eduSubject对象
              EduSubject eduSubject = oneSubjectList.get(i);
              //把eduSubject里面值获取出来，放到OneSubject对象里面
              OneSubject oneSubject = new OneSubject();
  //            oneSubject.setId(eduSubject.getId());
  //            oneSubject.setTitle(eduSubject.getTitle());
              //eduSubject值复制到对应oneSubject对象里面
              BeanUtils.copyProperties(eduSubject,oneSubject);
              //多个OneSubject放到finalSubjectList里面
              finalSubjectList.add(oneSubject);
  
              //在一级分类循环遍历查询所有的二级分类
              //创建list集合封装每个一级分类的二级分类
              List<TwoSubject> twoFinalSubjectList = new ArrayList<>();
              //遍历二级分类list集合
              for (int m = 0; m < twoSubjectList.size(); m++) {
                  //获取每个二级分类
                  EduSubject tSubject = twoSubjectList.get(m);
                  //判断二级分类parentid和一级分类id是否一样
                  if(tSubject.getParentId().equals(eduSubject.getId())) {
                      //把tSubject值复制到TwoSubject里面，放到twoFinalSubjectList里面
                      TwoSubject twoSubject = new TwoSubject();
                      BeanUtils.copyProperties(tSubject,twoSubject);
                      twoFinalSubjectList.add(twoSubject);
                  }
              }
              //把一级下面所有二级分类放到一级分类里面
              oneSubject.setChildren(twoFinalSubjectList);
          }
          return finalSubjectList;
      }
  ```

```
* ##### 在前端的api下面创建js文件

```java
import request from '@/utils/request'
export default {
  // 课程分类列表
  getSubjectList() {
    return request({
      url: '/eduService/subject/getAllSubject',
      method: 'get'
    })
  }
}
```

* ##### 创建对应的页面
  
  ```java
  <template>
    <div class="app-container">
      <el-input v-model="filterText" placeholder="Filter keyword" style="margin-bottom:30px;" />
  
      <el-tree
        ref="tree2"
        :data="data2"
        :props="defaultProps"
        :filter-node-method="filterNode"
        class="filter-tree"
        default-expand-all
      />
  
    </div>
  </template>
  
  <script>
  import subject from '@/api/edu/subject'
  export default {
  
    data() {
      return {
        filterText: '',
        data2: [], // 返回所有分类数据
        defaultProps: {
          children: 'children',
          label: 'title'
        }
      }
    },
    watch: {
      filterText(val) {
        this.$refs.tree2.filter(val)
      }
    },
    created() {
      this.getAllSubjectList()
    },
  
    methods: {
      getAllSubjectList() {
        subject.getSubjectList()
          .then(response => {
            this.data2 = response.data.list
          })
      },
      filterNode(value, data) {
        if (!value) return true
        return data.title.toLowerCase().indexOf(value.toLowerCase()) !== -1
      }
    }
  }
  </script>
  ```

## **<u>第七 八 九天创建课程发布模块</u>**

### 第一步 在数据库内建对应的表

### 第二步 通过代码生成器用对应的表 生成对应的类

```java
  StrategyConfig strategy = new StrategyConfig();

        strategy.setInclude("edu_course","edu_course_description","edu_chapter","edu_video");
```

### 第三步 编写接口代码

* 细节 创建vo实体类用于封装数据
  
  ```java
  CourseInfoVo
  ```

* 编写controller类
  
  ```java
  @RestController
  @RequestMapping("/eduService/course")
  @CrossOrigin
  public class EduCourseController {
  
      @Autowired
      private EduCourseService coursesService;
  
      /**
       * 添加课程的基本信息的方法
       * */
      @PostMapping("addCourseInfo")
      public ResultBack addCourseInfo(@RequestBody CourseInfoVo courseInfo){
          coursesService.saveCourseInfo(courseInfo);
          return ResultBack.ok();
      }
  }
  ```

* 编写serviceImpl类
  
  ```java
  @Service
  public class EduCourseServiceImpl extends ServiceImpl<EduCourseMapper, EduCourse> implements EduCourseService {
  ```

```java
  @Autowired
  private EduCourseDescriptionService courseDescriptionService;
  /**
   * 添加课程基本信息的方法
   *
   * @param courseInfo 用来封装数据的类
   */
  @Override
  public void saveCourseInfo(CourseInfoVo courseInfo) {
      //向课程表中添加课程的基本信息
      //CourseInfoVo对象转换eduCourse对象
      EduCourse eduCourse = new EduCourse();
      BeanUtils.copyProperties(courseInfo, eduCourse);
      int insert = baseMapper.insert(eduCourse);
      if (insert<=0){
          throw new IllegalStateException("无语的问题");
      }
      //获取添加之后的课程id
      String cid = eduCourse.getId();

      //向课程简介表添加课程简介
      EduCourseDescription courseDescription = new EduCourseDescription();
      courseDescription.setDescription(courseInfo.getDescription());
      //设置描述的id就是课程id
      courseDescription.setId(cid);
      courseDescriptionService.save(courseDescription);
  }
```

- 把表单提交过来的数据添加数据库

- 把讲师 和 分类做成二级联动效果

## 课程发布模块

- #### 创建对应的章节和小结实体类--chapterVo 和 VideoVo

- #### 编写对应的controller和service接口

- #### 编写对应的service实现类

```java
```java
@Service
public class EduChapterServiceImpl extends ServiceImpl<EduChapterMapper, EduChapter> implements EduChapterService {

    @Autowired
    private EduVideoService videoService;
    /**
     * 通过id查询课程大纲列表
     *
     * @param courseId 课程id
     * @return 课程列表数据
     */
    @Override
    public List<ChapterVo> getChapterVideoByCourseId(String courseId) {
        //根据课程id查询里面所有的章节
        QueryWrapper<EduChapter> wrapperChapter = new QueryWrapper<>();
        wrapperChapter.eq("course_id",courseId);
        List<EduChapter> eduChapterList = baseMapper.selectList(wrapperChapter);

        //根据课程id查询课程里面所有的小节
        QueryWrapper<EduVideo> wrapperVideo = new QueryWrapper<>();
        wrapperVideo.eq("course_id",courseId);
        List<EduVideo> eduVideoList = videoService.list(wrapperVideo);

        //遍历查询章节list集合进行封装
        //对章节进行遍历
        List<ChapterVo> finalList = new ArrayList<>();
        for (int i = 0; i < eduChapterList.size(); i++) {
            //每个章节
            EduChapter eduChapter = eduChapterList.get(i);
            //把eduChapter 的值 复制到 chapterVo里面去
            ChapterVo chapterVo = new ChapterVo();
            BeanUtils.copyProperties(eduChapter,chapterVo);
            finalList.add(chapterVo);

            //对小节进行遍历
            List<VideoVo> videoList = new ArrayList<VideoVo>();
            for (int j = 0; j < eduVideoList.size(); j++) {
                //得到每个小节
                EduVideo eduVideo = eduVideoList.get(j);
                //判断 小节的 chapterId是否和章节里面的 id一样
                if (eduVideo.getChapterId().equals(eduChapter.getId())) {
                    VideoVo videoVo = new VideoVo();
                    BeanUtils.copyProperties(videoList,videoVo);
                    videoList.add(videoVo);
                }
            }
            //把封装后的小节集合 放到章节对象里面
            chapterVo.setChildren(videoList);
        }
        return finalList;
    }
}
```

# 增删改查大家庭

## 后端

### controller类

```java
@RestController
@RequestMapping("/eduservice/course")
@CrossOrigin
public class EduCourseController {

    @Autowired
    private EduCourseService coursesService;

    /**
     * 添加课程的基本信息的方法
     */
    @PostMapping("addCourseInfo")
    public ResultBack addCourseInfo(@RequestBody CourseInfoVo courseInfo) {

        String id = coursesService.saveCourseInfo(courseInfo);
        return ResultBack.ok().data("courseId", id);
    }

    /**
     * 根据课程查询课程基本信息
     */
    @GetMapping("getCourseInfo/{courseId}")
    public ResultBack getCourseInfo(@PathVariable String courseId) {
        CourseInfoVo courseInfoVo = coursesService.getCourseInfo(courseId);
        return ResultBack.ok().data("courseInfoVo", courseInfoVo);
    }

    /**
     * 修改课程信息
     * */
    @PostMapping("updateCourseInfo")
    public ResultBack updateCourseInfo(@RequestBody CourseInfoVo courseInfoVo){
        coursesService.updateCourseInfo(courseInfoVo);
        return ResultBack.ok().data("courseInfoVo", courseInfoVo);
    }
    /**
     * 删除操作
     * */
    @DeleteMapping("{id}")
    public ResultBack deleteVideo(@PathVariable String id){
        coursesService.removeById(id);
        return ResultBack.ok();
    }
}
```

* ## 增

```java
  @Autowired
    private EduCourseDescriptionService courseDescriptionService;
    /**
     * 添加课程基本信息的方法
     *
     * @param courseInfo 用来封装数据的类
     */
    @Override
    public String saveCourseInfo(CourseInfoVo courseInfo) {
        //向课程表中添加课程的基本信息
        //CourseInfoVo对象转换eduCourse对象
        EduCourse eduCourse = new EduCourse();
        BeanUtils.copyProperties(courseInfo, eduCourse);
        int insert = baseMapper.insert(eduCourse);
        if (insert<=0){
            throw new IllegalStateException("无语的问题");
        }
        //获取添加之后的课程id
        String cid = eduCourse.getId();

        //向课程简介表添加课程简介
        EduCourseDescription courseDescription = new EduCourseDescription();
        courseDescription.setDescription(courseInfo.getDescription());
        //设置描述的id就是课程id
        courseDescription.setId(cid);
        courseDescriptionService.save(courseDescription);
        return cid;
    }
```

* ## 删

```java
 /**
     * 通过id删除章节
     *
     * @param chapterId 章节对应的id值
     */
    @Override
    public boolean deleteChapter(String chapterId) {
        //根据chapterid章节id 查询小节表，如果查询到数据 则不进行删除
        QueryWrapper<EduVideo> wrapper = new QueryWrapper<EduVideo>();
        wrapper.eq("chapter_id",chapterId);
        int count = videoService.count(wrapper);
        //判断是否存在数据
        if (count>0){
            throw new IllegalStateException("不能删除");
        }else{
            int res = baseMapper.deleteById(chapterId);
            return res>0;
        }
    }
```

* ## 改

```java
 /**
     * 修改课程的方法
     *
     * @param courseInfoVo 获取到的数据
     */
    @Override
    public void updateCourseInfo(CourseInfoVo courseInfoVo) {
        //修改课程表
        EduCourse eduCourse = new EduCourse();
        BeanUtils.copyProperties(courseInfoVo,eduCourse);
        int update = baseMapper.updateById(eduCourse);
        if (update==0){
            throw new IllegalStateException("我不想写报错信息");
        }

        //修改描述表
        EduCourseDescription description = new EduCourseDescription();
        description.setId(courseInfoVo.getId());
        description.setDescription(courseInfoVo.getDescription());
        courseDescriptionService.updateById(description);
    }
}
```

* ## 查

```java
    @Autowired
    private EduVideoService videoService;
    /**
     * 通过id查询课程大纲列表
     *
     * @param courseId 课程id
     * @return 课程列表数据
     */
    @Override
    public List<ChapterVo> getChapterVideoByCourseId(String courseId) {
        //根据课程id查询里面所有的章节
        QueryWrapper<EduChapter> wrapperChapter = new QueryWrapper<>();
        wrapperChapter.eq("course_id",courseId);
        List<EduChapter> eduChapterList = baseMapper.selectList(wrapperChapter);

        //根据课程id查询课程里面所有的小节
        QueryWrapper<EduVideo> wrapperVideo = new QueryWrapper<>();
        wrapperVideo.eq("course_id",courseId);
        List<EduVideo> eduVideoList = videoService.list(wrapperVideo);

        //遍历查询章节list集合进行封装
        //对章节进行遍历
        List<ChapterVo> finalList = new ArrayList<>();
        for (int i = 0; i < eduChapterList.size(); i++) {
            //每个章节
            EduChapter eduChapter = eduChapterList.get(i);
            //把eduChapter 的值 复制到 chapterVo里面去
            ChapterVo chapterVo = new ChapterVo();
            BeanUtils.copyProperties(eduChapter,chapterVo);
            finalList.add(chapterVo);

            //对小节进行遍历
            List<VideoVo> videoList = new ArrayList<VideoVo>();
            for (int j = 0; j < eduVideoList.size(); j++) {
                //得到每个小节
                EduVideo eduVideo = eduVideoList.get(j);
                //判断 小节的 chapterId是否和章节里面的 id一样
                if (eduVideo.getChapterId().equals(eduChapter.getId())) {
                    VideoVo videoVo = new VideoVo();
                    BeanUtils.copyProperties(videoList,videoVo);
                    videoList.add(videoVo);
                }
            }
            //把封装后的小节集合 放到章节对象里面
            chapterVo.setChildren(videoList);
        }
        return finalList;
    }
```

## 前端

```java
import request from '@/utils/request'
export default {
  // 根据课程id获取章节和小节数据列表
  getAllChapterVideo(courseId) {
    return request({
      url: '/eduservice/educhapter/getChapterVideo/' + courseId,
      method: 'get'
    })
  },
  // 添加章节的方法
  addChapter(chapter) {
    return request({
      url: '/eduservice/chapter/addChapter',
      method: 'post',
      data: chapter
    })
  },
  // 根据id查询章节
  getChapter(chapterId) {
    return request({
      url: '/eduservice/chapter/getChapterInfo/' + chapterId,
      method: 'get'
    })
  },
  // 修改章节
  updateChapter(chapter) {
    return request({
      url: '/eduservice/chapter/updateChapter',
      method: 'post',
      data: chapter
    })
  },
  // 删除章节
  deleteChapter(chapterId) {
    return request({
      url: '/eduservice/chapter/deleteChapter',
      method: 'delete'
    })
  }
}
```

# <mark>视频功能 -- 没做 上面还有些前端的页面没写 有一些bug没处理，你自己看着来吧</mark>

# <mark> <u> 十天 springCloud微服务--跳了</u></mark>

## 简介：

* springcloud并不是一种技术，而是很多技术的总称或者集合

* springcloud里面有很多框架，使用springcloud里面这些框架实现微服务操作

* 使用springcloud需要依赖技术springboot

# 十一天 搭建前台环境</u>**

## NUXT

> 注：导入的文件是template
> 
>         需要先执行npm-install并进行对应内容的填写

* #### 首先进行幻灯片创建安装安装
  
  ```java
  npm install swiper swiper@3.4.2 --save-dev
  ```

* #### 编写插件配置文件
  
  * 在plugins下面创建nuxt-swiper-plugin.js
  
  ```java
  import Vue from 'vue'
  import VueAwesomeSwiper from 'vue-awesome-swiper/dist/ssr'
  
  Vue.use(VueAwesomeSwipnpm install swiper swiper@3.4.2 --save-dever)
  ```

* #### 配置文件中编写
  
  * 在nuxt.config.js下面开头位置输入

```java
  plugins: [{src: '~/plugins/nuxt-swiper-plugin.js',ssr: false}],
  css:['swiper/dist/css/swiper.css'],
```

## 整合前台系统页面

* #### 导入静态资源到assets里面

* #### 更改layouts下面的default页面

* #### 更改pages下面的index页面

## 路由跳转-静态路由

* 通过to属性设置路由跳转路径
  
  ```java
     // 跳转到course下面的页面
         <router-link to="/course" tag="li" active-class="current">
  ```

* 通过在pages下面创建course文件夹里面负责编写vue页面

## 路由跳转-动态路由

> 动态路由是以下划线开头的vue文件，参数名为下划线后边的文件名

## 幻灯片功能实现

### 创建对应的service-cms模块

* ##### 创建对应的配置文件
  
  ```java
  # 服务端口
  service.port=8004
  
  # 服务名
  spring.application.name=service-cms
  
  #激活配置文件 需要指定其他的配置文件名称
  spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
  spring.datasource.url=jdbc:mysql://localhost:3306/guli-school?serverTimezone=GMT
  spring.datasource.username=pc
  spring.datasource.password=123456
  
  #mybatis
  mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
  #环境配置
  spring.profiles.active=dec
  #返回json的全局时间格式
  spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
  spring.jackson.time-zone=GMT+8
  
  #配置mapper xml文件的路径
  mybatis-plus.mapper-locations=classpath:com/pc/educms/mapper/xml/*.xml
  ```

* ##### 创建对应的数据库表（crm-banner），通过代码生成器创建对应的代码

* #### banner接口
  
  ```java
  public class BannerFrontController {
  
      @Autowired
      private CrmBannerService crmBannerService;
  
      /**
       * 查询所有banner
       * */
      @GetMapping("getAllBanner")
      public ResultBack getAllBanner(){
          List<CrmBanner> list = crmBannerService.selectAllBanner();
          return ResultBack.ok().data("list",list);
      }
  }
  ```

### 热门课程和名师查询

```java
/**
 * @author foreverqisui
 * 查询八条热门课程 查询四条名师
 */
@RestController
@RequestMapping("eduservice/indexfront")
@CrossOrigin
public class IndexFrontController {

    @Autowired
    private EduCourseService coursesService;

    @Autowired
    private EduTeacherService teachersService;

    @GetMapping("index")
    public ResultBack index() {
        //查询前八条热门课程
        QueryWrapper<EduCourse> wrapper = new QueryWrapper<EduCourse>();
        wrapper.orderByDesc("id");
        wrapper.last("limit 8");
        List<EduCourse> eduList = coursesService.list(wrapper);

        //查询四条名师
        QueryWrapper<EduTeacher> wrapperTeacher = new QueryWrapper<>();
        wrapperTeacher.orderByDesc("id");
        wrapperTeacher.last("limit 4");
        List<EduTeacher> teacherList = teachersService.list(wrapperTeacher);
        return ResultBack.ok().data("eduList",eduList).data("teacherList",teacherList);
    }
}
```

## axios使用

* ##### 安装指令
  
  ```java
  npm install axios
  ```

* ##### 封装axios
  
  * 创建util文件夹 下面创建reques.js文件

```java
import axios from 'axios';
// 创建axios实例
const service = axios.create({
    baseUrl: 'http://localhost:9001',
    timeout: 20000
})
export default service;
```

## 首页banner进行显示

* 创建api文件夹 在下面创建banner.js
  
  ```java
  import request from '@/util/request';
  
  export default{
      // 查询前两条的banner数据
      getListBanner(){
          return request({
              url: '/educms/bannerfront/getAllBanner',
              method: 'GET'
          })
      }
  }
  ```

## <mark>页面没有进行数据展示 swagger测试成功 可能与nacos没配置有关</mark>

## Redis使用

### 特点

* 基于key-value存储

* 支持多种数据结构

* 支持持久化 通过内存进行存储，也可以存储在硬盘里面

* 支持过期时间 支持事务

### 使用步骤

* 引入相关依赖在common-service bases
  
  ```java
     <!-- redis -->
          <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-data-redis</artifactId>
          </dependency>
  
          <!-- spring2.X集成redis所需common-pool2-->
          <dependency>
              <groupId>org.apache.commons</groupId>
              <artifactId>commons-pool2</artifactId>
              <version>2.6.0</version>
          </dependency>
  ```

* 配置配置类
  
  ```java
  /**
   * @author foreverqisui
   */
  @EnableCaching 
  //开启缓存
  @Configuration  
  //配置类
  public class RedisConfig extends CachingConfigurerSupport {
  
      @Bean
      public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
          RedisTemplate<String, Object> template = new RedisTemplate<>();
          RedisSerializer<String> redisSerializer = new StringRedisSerializer();
          Jackson2JsonRedisSerializer<? extends Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
          ObjectMapper om = new ObjectMapper();
          om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
          om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
          jackson2JsonRedisSerializer.setObjectMapper(om);
          template.setConnectionFactory(factory);
          //key序列化方式
          template.setKeySerializer(redisSerializer);
          //value序列化
          template.setValueSerializer(jackson2JsonRedisSerializer);
          //value hashmap序列化
          template.setHashValueSerializer(jackson2JsonRedisSerializer);
          return template;
      }
  
      @Bean
      public CacheManager cacheManager(RedisConnectionFactory factory) {
          RedisSerializer<String> redisSerializer = new StringRedisSerializer();
          Jackson2JsonRedisSerializer<? extends Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
          //解决查询缓存转换异常的问题
          ObjectMapper om = new ObjectMapper();
          om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
          om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
          jackson2JsonRedisSerializer.setObjectMapper(om);
          // 配置序列化（解决乱码的问题）,过期时间600秒
          RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                  .entryTtl(Duration.ofSeconds(600))
                  .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                  .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                  .disableCachingNullValues();
          RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                  .cacheDefaults(config)
                  .build();
          return cacheManager;
      }
  }
  build();
          return cacheManager;
      }
  }
  ```

* 在查询所有banner的方法上面添加缓存注解@Cacheable

* 缓存的基本过程
  
  * 第一次查询 首先查询数据库，把数据库查询数据返回，并且返回数据放到缓存中
  
  * 第二次查询 查询缓存 发现缓存有数据 直接返回
  
  ```java
      //添加缓存
      @Cacheable(value = "banner",key="selectIndexList")
  ```

## redis缓存未进行添加</mark>

# **<u>十二天 首页的登录和注册功能</u>**

## SSO（单点登录）

* #### 三种常见方式
  
  * 第一种：session广播机制 -- session复制
  
  * 第二种：使用cookie+redis实现
    
    * 把登录所产生的数据放到两个地方
      
      * redis：key中：生成唯一随机值（ip、id等） value中: 用户数据
      
      * cookie：把redis里面生成key值放到cookie里面
    
    * 访问项目中其他模块时，发送请求带着cookie进行发送，获取cookie值，拿着cookie做事情
      
      * 把cookie获取值，到redis进行查询，根据key进行查询，如果能查询到数据就登陆
  
  * 第三种：使用token实现
    
    * 什么是token（自包含令牌）
      
      * 按规则生成字符串，字符串包含用户信息
    
    * 在项目某个模块进行登陆，登陆之后，按照规则生成字符串，把登录之后用户包含到生成字符串里面，把字符串返回
      
      * 可以把字符串通过cookie返回
      
      * 把字符串通过地址栏返回

* #### JWT
  
  * 定义：就是规定好了规则，使用jwt规则可以生成字符串，包含用户信息
  
  * 由三部分组成
    
    * 第一部分 jwt头信息
    
    * 第二部分 有效载荷 包含主体信息（用户信息）
    
    * 第三部分 签名哈希 防伪标志

* 使用步骤
  
  * 导入依赖--common-utils模块里
    
    ```java
            <!--jwt依赖-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
            </dependency>
    ```
  
  * 创建jwt工具类
    
    ```java
    package com.pc.common_utils;
    ```

```java
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.util.StringUtils;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;

/**
 * @author foreverqisui
 */
public class JwtUtils {

    /**
     * 设置过期时间
     * */
    public static final long EXPIRE = 1000 * 60 * 60 * 24;
    /**
     * 设置秘钥
     * */
    public static final String APP_SECRET = "ukc8BDbRigUDaY6pZFfWus2jZWLPHO";

    /**
     * 生成token字符串的方法 
     * @param id 输入的id值
     * */
    public static String getJwtToken(String id, String nickname){

        String JwtToken = Jwts.builder()
                //表头设置
                .setHeaderParam("typ", "JWT")
                .setHeaderParam("alg", "HS256")

                //设置过期时间 当前时间+设定的过期时间
                //guli-user 设置分类值
                .setSubject("guli-user")
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))

                //设置token主体部分 可加多条
                .claim("id", id)
                .claim("nickname", nickname)

                //签名哈希 
                .signWith(SignatureAlgorithm.HS256, APP_SECRET)
                .compact();

        return JwtToken;
    }

    /**
     * 判断token是否存在与有效
     */
    public static boolean checkToken(String jwtToken) {
        if(StringUtils.isEmpty(jwtToken)) {
            return false;
        }
        try {
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * 判断token是否存在与有效
     */
    public static boolean checkToken(HttpServletRequest request) {
        try {
            String jwtToken = request.getHeader("token");
            if(StringUtils.isEmpty(jwtToken)) {
                return false;
            }
            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * 根据token获取会员id
     */
    public static String getMemberIdByJwtToken(HttpServletRequest request) {
        String jwtToken = request.getHeader("token");
        if(StringUtils.isEmpty(jwtToken)) {
            return "";
        }
        Jws<Claims> claimsJws = Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);
        Claims claims = claimsJws.getBody();
        return (String)claims.get("id");
    }
}
```

```
* ### 短信服务--阿里云

  * 创建模块service-msm 用来整合阿里云短信服务

  * 找到短信服务功能并开通

  * 进入控制台 -- 点击国内消息 

  * 添加模块管理的短信模板

  * 申请签名模板

* ### 开发步骤

  * 导入依赖

  ```java
```

* 创建controller类、
  
  ```java
  @RestController
  @RequestMapping("/edumsm/msm")
  @CrossOrigin
  public class MsmController {
  
    @Autowired
    private MsmService msmService;
  
    /**
     * 发送短信的方法
     */
    @GetMapping("send/{phone}")
    public ResultBack sendMsm(@PathVariable String phone){
        //生成随机值，传递阿里云进行发送
        String code = RandomUtil.getFourBitRandom();
        Map<String ,Object> param = new HashMap<>();
        param.put("code", code);
        //调用service发送短信的方法
        boolean isSend = msmService.send(param,phone);
        if (isSend) {
            return ResultBack.ok();
        }else {
            return ResultBack.error().message("MsmCtroller类中的发送短信方法出现意外");
        }
    }
  }
  ```

* 创建接口

* 创建实现类

* <mark>加入缓存功能------------TODO</mark>

```java
@RestController
@RequestMapping("/edumsm/msm")
@CrossOrigin
public class MsmController {

    @Autowired
    private MsmService msmService;

    /**
     * redis整合 注入
     * */
    @Autowired
    private RedisTemplate<String,String> redisTemplate;

    /**
     * 发送短信的方法
     */
    @GetMapping("send/{phone}")
    public ResultBack sendMsm(@PathVariable String phone){
        //从redis获取验证码，如果获取到直接返回
        String code = redisTemplate.opsForValue().get(phone);
        if (!StringUtils.isEmpty(code)){
            return ResultBack.ok();
        }

        //生成随机值，传递阿里云进行发送
         code = RandomUtil.getFourBitRandom();
        Map<String ,Object> param = new HashMap<>();
        param.put("code", code);
        //调用service发送短信的方法
        boolean isSend = msmService.send(param,phone);
        if (isSend) {
            //发送成功，把发送成功的验证码放到redis里面
            redisTemplate.opsForValue().set(phone,code,5, TimeUnit.MINUTES);
            return ResultBack.ok();
        }else {
            return ResultBack.error().message("MsmCtroller类中的发送短信方法出现意外");
        }
    }
}
```

### 注册登录功能

* 创建数据库表 UCenter_member 通过代码生成器进行相关代码的生成

* 登录注册的controller
  
  ```java
  package com.pc.educenter.controller;
  - import com.pc.common_utils.ResultBack;
    import com.pc.educenter.entity.UcenterMember;
    import com.pc.educenter.service.UcenterMemberService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.*;
  
    /**
  
  - <p>
  
  - 会员表 前端控制器
  
  - </p>
  ```
- @author testjava

- @since 2022-02-23
  */
  @RestController
  @RequestMapping("/educenter/member")
  @CrossOrigin
  public class UcenterMemberController {
  
  @Autowired
   private UcenterMemberService meberService;
  
  /**
  
  - 登录功能
  
  - */
    @GetMapping("login")
    public ResultBack login(@RequestBody UcenterMember member){
     //调用service方法 实现登录
     //返回token值，使用jwt生成
     String token = meberService.login(member);
     return ResultBack.ok().data("token",token);
    }
    
    /**
  
  - 注册功能
  
  - */
    @PostMapping("register")
    public ResultBack register(@RequestBody RegisterVo registerVo){
     meberService.register(registerVo);
     return ResultBack.ok();
    }
    }
    
    ```
    
    ```
* MD5用于密码加密
  
  ```java
  
  ```
