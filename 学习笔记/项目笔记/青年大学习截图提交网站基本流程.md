[TOC]

# 主要功能

> 青年大学习截图收取，并有实时排行榜，帮助团支书及时发现没有按时提交的人

# 主要技术

> ## springboot+vue3+elementUI
> 
> * 登录方式采用jwt单点登录，将信息存储在cookie里面
> 
> * 借用oss阿里云的云存储进行照片的收集
> 
> * 定时任务，在每周五12点 更新 所有人的状态为未提交

# 前端

> ## 目前四个简易页面
> 
> * 登录页面
> 
> * 注册页面
> 
> * 提交页面
> 
> * 排行榜页面

## 登录页面主要实现

> ### 基本的登录页面，不过用了下jwt单点登录
> 
> 效果如下
> 
> ![登录页面.png](D:\A-工作文档\学习文档\学习笔记\csdn博客\登录页面.png)
> 
> 简简单单，做了个栅格，就没了，逻辑都在后台，前面就是配置了拦截器，调用后端接口获得后端生成的token，存入header里面，再根据后端接口提供的方法，在获取用户信息。
> 
> ```js
> //请求拦截器
> service.interceptors.request.use(
>     //config配置对象
>     config => {
>         //判断cookie中是否包含名称是cookiname的数据
>         if(cookie.get('cookieName')){
>             //把cookie里面的值放到header里面
>             config.headers['token'] = cookie.get('cookieName');
>         }
>         return config;
>     },
>     error => {
>         console.log(error);
>         return Promise.reject();
>     }
> );
> ```
> 
> ```js
>     //jwt登录
>     function loginByToken() {
>       userInfo.loginByToken(param).then((res) => {
>         //获取token值
>         let token = res.data.token;
>         //放入cookie中 【第一个参数 是名字，第二个参数是信息，第三个参数是作用域】
>         cookie.set("cookieName", token, { domain: "localhost" });
>         //根据头信息中的token查询信息
>         //再将查询的信息放到cookie中
>         getUserInfoByToken();
>         router.push("/loginIndex")
>       });
>     }
>     //根据token查询信息的方法
>     function getUserInfoByToken() {
>       userInfo.getUserInfoByToken().then((res) => {
>         let data = JSON.stringify(res.data.userInfo);
>         cookie.set("userInfo", data, { domain:'localhost'})
>       });
>     }
> ```

## 注册页面主要实现

> 就很简单了，调用的后端接口直接提交了，效果如下
> 
> ![注册页面 (2).png](D:\A-工作文档\学习文档\学习笔记\csdn博客\注册页面%20(2).png)
> 
> 代码就不写了，elementUi现成的

## 主页面主要实现

> 主页面主要就是一个card和一个上传的组件，因为用cookie登录的，所以还有一个退出登录用来清空cookie，信息都是数据库中实时的，头像可以从oss上面提取，但是懒就没有改
> 
> ![主页面.png](D:\A-工作文档\学习文档\学习笔记\csdn博客\主页面.png)
> 
> 代码如下，主要是js代码，因为页面都是现成的组件
> 
> ```js
>   //根据cookie中的信息获取用户信息
>     function getUserInfoByToken() {
>       let cookieInfo = cookie.get("userInfo");
>       if (cookieInfo) {
>         formLabelAlign.params = JSON.parse(cookieInfo);
>       }
>     }
> 
>     //退出登录
>     function logout() {
>       cookie.set("userInfo", "", { domain: "localhost" });
>       cookie.set("cookieName", "", { domain: "localhost" });
>       router.push("/").then(() => {
>         window.location.reload();
>       });
>     }
>     //上传照片后执行的操
>     function uploadOss() {
>       ElMessage.success("上传成功");
>       router.push("/uploadForm").then(() => {
>         uploadTimes();
>         window.location.reload();
>       });
>     }
> ```

## 排行页面主要实现

> 排行榜排名根据提交照片的时间进行排序，没提交的状态是红色，提交的状态是绿色，按道理红色应该在下面，应该是做测试的时候时间改乱了，效果如下
> 
> ![排行页面.png](D:\A-工作文档\学习文档\学习笔记\csdn博客\排行页面.png)
> 
> 本来是有分页的，因为某些原因没放上去，简单的js
> 
> ```js
>   setup() {
>     const value = ref("100");
>     const router = useRouter();
>     const user = reactive({
>       username: "Aa潘七岁",
>     });
>     const query = reactive({
>       current: 1,
>       limit: 4,
>       formInfo: {},
>       list: [],
>       total: 10,
>     });
>     // 获取表格数据
>     function getData(page = 1) {
>       query.current = page;
>       login
>         .uploadForm(query.current, query.limit, query.formInfo)
>         .then((res) => {
>           query.list = res.data.uploadPage.records;
>         });
>     }
> ```

# 后端

> 就很基础的增删改查了，用了nginx

## 单点登录的两个controller，没什么好写的了其他

> ```java
>  /**
>      * 使用token进行登陆
>      */
>     @PostMapping("loginByToken")
>     public ResultBack loginByToken(@RequestBody LoginTable loginTable) {
>         //发送token值给前端
>         String token = loginService.loginByToken(loginTable);
>         return ResultBack.ok().data("token", token);
>     }
> 
>     /**
>      * 获取头信息中的token 返回用户信息
>      */
>     @GetMapping("getByToken")
>     public ResultBack getByToken(HttpServletRequest request) {
>         //根据request的对象头获取头信息 返回用户id
>         String id = Jwt.getMemberIdByJwtToken(request);
>         //根据id获取用户信息
>         LoginTable loginTable = loginService.getById(id);
>         Map<String, Object> map = new HashMap<>();
>         map.put("userInfo", loginTable);
>         return ResultBack.ok().data(map);
>     }
> ```

## oss上传，其实也没什么写的，阿里云的文档写的非常好

> ```java
> @Service
> public class FileServiceImpl implements FileService {
>     /**
>      * 文件上传功能
>      *
>      * @param file ：上传的文件
>      * @return 存储在oss的地址
>      */
>     @Override
>     public String uploadFile(MultipartFile file) {
>         // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。
>         String endpoint = ConstansOssUtils.END_POIND;
>         // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。
>         String accessKeyId = ConstansOssUtils.ACCESS_KEY_ID;
>         String accessKeySecret = ConstansOssUtils.ACCESS_KEY_SECRET;
>         // 填写Bucket名称，例如examplebucket。
>         String bucketName = ConstansOssUtils.BUCKET_NAME;
>         //获取文件名称
>         String fileName = file.getOriginalFilename();
>         //把文件按照日期进行分类
>         //获取当前日期
>         String datePath = new DateTime().toString("yyyy/MM/dd");
>         //进行拼接
>         fileName = datePath + "/" + fileName;
>         System.out.println(fileName);
>         // 创建OSSClient实例。
>         OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
>         try {
>             InputStream inputStream = file.getInputStream();
>             // 创建PutObject请求。
>             ossClient.putObject(bucketName, fileName, inputStream);
> 
>             ossClient.shutdown();
>             //返回照片路径 通过路径拼接
>             return "https://" + bucketName + "." + endpoint + "/" + fileName;
> 
>         } catch (IOException e) {
>             e.printStackTrace();
>             return "你是傻逼";
>         }
> 
>     }
> }
> 
> 
> ```

## 最后是一个定时器的使用

> quartz那个框架没用明白，之后用的两个注解

> 启动类上：@EnableScheduling
> 
> 之后构建一个类，写的不太符合逻辑，先这样对付吧，改不动了
> 
> ```java
> @Component
> public class JobTask {
>     @Autowired
>     LoginService loginService;
> 
>     //在每周五12点进行更新操作
>     @Scheduled(cron = "0 0 12 ? * FRI")
>     public void jobTask(){
>         LoginTable loginTable = new LoginTable();
>         for (int i = 0; i < 10; i++) {
>             loginTable.setId(i);
>             loginService.updateStatus(loginTable);
>         }
>     }
> }
> 
> ```

大概就是这么一个小demo，很简单但是从0开始做还是很苦恼的，没人带着很多bug还是很吐血的，终究是吃了没技术的亏，想部署上线，但是又觉得麻烦，先这样吧.....未完待续


